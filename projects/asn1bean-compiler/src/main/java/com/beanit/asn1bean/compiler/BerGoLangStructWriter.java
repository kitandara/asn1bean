package com.beanit.asn1bean.compiler;

import com.beanit.asn1bean.ber.BerTag;
import com.beanit.asn1bean.compiler.model.*;
import com.beanit.asn1bean.util.HexString;

import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import static java.nio.charset.StandardCharsets.UTF_8;

public class BerGoLangStructWriter extends BerJavaClassWriter implements BerImplementationWriter {

  private static final String LIB_SRC = "github.com/kitandara/asn1ber";
  private static final String LIB_PREFIX = "asn1";
  private static final String GOLANG_VERSION = "1.23";

  public BerGoLangStructWriter(HashMap<String, AsnModule> modulesByName,
      String outputBaseDir,
      String basePackageName, boolean disableWritingVersion) {
    super(modulesByName, outputBaseDir, basePackageName, false, disableWritingVersion, false);

    if (this.basePackageName.endsWith(".")) {
      this.basePackageName = basePackageName.substring(0, basePackageName.length() - 1); // Remove added '.'
    }
  }

  public void initOutputDir() throws IOException {
    // Write go.mod file
    Writer fileWriter = Files.newBufferedWriter(new File(outputBaseDir, "go.mod").toPath(), UTF_8);
    BufferedWriter bf = new BufferedWriter(fileWriter);
    bf.write("module " + this.basePackageName + "\n\n");
    bf.write("go " + GOLANG_VERSION + "\n");
    bf.close();
    fileWriter.close();
  }

  @Override
  protected String moduleToPackageName(String moduleName) {
    return Utils.moduleToPackageName(moduleName, "/");
  }

  @Override
  protected void writeClassHeader(String typeName, AsnModule module) throws IOException {
    //noinspection ResultOfMethodCallIgnored
    outputDirectory.mkdirs();

    Writer fileWriter =
        Files.newBufferedWriter(new File(outputDirectory, typeName + ".go").toPath(), UTF_8);
    out = new BufferedWriter(fileWriter);

    String versionString = "";
    if (insertVersion) {
      versionString = " v" + Compiler.VERSION;
    }

    write("/*");
    write(
        " * This class file was automatically generated by ASN1bean"
            + versionString
            + " (http://www.beanit.com)\n */\n");
    write("package " + basePackageName + "/" + Utils.lastPartOfPackageName(module.moduleIdentifier.name) + "\n");

    write("import (\n"
        + "\t\"encoding/hex\"\n"
        + "\t\"errors\"\n"
        + "\t\"fmt\"\n"
        + LIB_PREFIX + " \"" + LIB_SRC + "\"\n"
        + "\t\"io\"\n\n");

    // Import from others...
    List<String> importedClassesFromOtherModules = new ArrayList<>();

    for (SymbolsFromModule symbolsFromModule : module.importSymbolFromModuleList) {
      AsnModule importedModule = modulesByName.get(symbolsFromModule.modref);
      for (String importedSymbol : symbolsFromModule.symbolList) {
        if (Character.isUpperCase(importedSymbol.charAt(0))) {
          if (importedModule.typesByName.get(importedSymbol) != null) {
            importedClassesFromOtherModules.add(
                moduleToPackageName(importedModule.moduleIdentifier.name)
                    + "/"
                    + Utils.cleanUpName(importedSymbol)
            );
          }
        }
      }
    }
    Collections.sort(importedClassesFromOtherModules);
    for (String modulePackage : importedClassesFromOtherModules) {
      write("import \"" + basePackageName + "/" + modulePackage + "\"");
    }
    write(")");
  }

  private String getModuleForType(String assignedTypeName) {

    if (module.typesByName.get(assignedTypeName) != null) {
      return null; // Internal to the module
    }
    for (SymbolsFromModule symbolsFromModule : module.importSymbolFromModuleList) {
      for (String sym : symbolsFromModule.symbolList) {
        if (sym.equalsIgnoreCase(assignedTypeName)) {
          return symbolsFromModule.modref;
        }
      }
    }
    return LIB_PREFIX;
  }

  @Override
  String getBerTagParametersString(BerImplementationWriter.Tag tag) {
    return LIB_PREFIX + "."
        + tag.tagClass
        + "_CLASS, " + LIB_PREFIX + "."
        + tag.typeStructure.toString()
        + ", "
        + tag.value;
  }


  @Override
  protected void writeRetaggingTypeClass(
      String typeName, String assignedTypeName, AsnType typeDefinition, BerImplementationWriter.Tag tag)
      throws IOException {

    String embeddedType = Utils.cleanUpName(assignedTypeName); // The embedded type.

    // Output the struct
    write("type " + typeName + " struct {");
    String importModuleName = getModuleForType(typeDefinition.name);
    write((importModuleName != null ? importModuleName + "." : "") + "" + embeddedType);

    write("}\n");

    // Write tag func
    if (tag != null) {
      write("func (b *" + typeName + ") GetTag () {");
      write("return " + LIB_PREFIX + ".NewBerTag(" + getBerTagParametersString(tag) + ")");
      write("}");

      // Ignore constructors, go straight to encoder/decode funcs
      write("func (b *" + typeName + ") Encode(reverseOS io.Writer, withTagList ...bool) (int, error) {");
      write("var withTag bool\n"
          + "\tif len(withTagList) > 0 {\n"
          + "\t\twithTag = withTagList[0]\n"
          + "\t} else {\n"
          + "\t\twithTag = true\n"
          + "\t}");
      write("codeLength := 0");
      write("var err error\n"
          + "\tvar n int");
      if (tag.type == BerImplementationWriter.TagType.EXPLICIT) {
        if (isDirectAnyOrChoice((AsnTaggedType) typeDefinition)) {
          write("n,err = b." + embeddedType + " .Encode(reverseOS)");
        } else {
          write("n,err = b." + embeddedType + ".Encode(reverseOS, true)");
        }
        write("if err != nil {\n"
            + "\t\treturn codeLength, err\n"
            + "\t}");

        write("codeLength += n");
        write("n,err = " + LIB_PREFIX + "EncodeLength(codeLength, reverseOS)");
        write("codeLength += n");

      } else {
        write("n,err = b." + embeddedType + ".Encode(reverseOS, false)");
      }
      write("if err != nil {\n"
          + "\t\treturn codeLength, err\n"
          + "\t}");

      write("if withTag {");
      write("n,err = b.GetTag().Encode(reverseOS)");
      write("codeLength += n");
      write("if err != nil {\n"
          + "\t\treturn codeLength, err\n"
          + "\t}");
      write("}\n");

      write("return codeLength,nil");
      write("}\n");

      // .. now write Decode
      write("func (b *" + typeName + ") Decode(is io.Reader, withTagList ...bool) (int, error) {");
      write("var withTag bool\n"
          + "\tif len(withTagList) > 0 {\n"
          + "\t\twithTag = withTagList[0]\n"
          + "\t} else {\n"
          + "\t\twithTag = true\n"
          + "\t}\n"
          + "\tcodeLength := 0");
      write("var err error\n"
          + "\tvar n int");
      write("if withTag {");
      write("n,err = b.GetTag().decodeAndCheck(is);");
      write("codeLength += n");
      write("if err != nil {\n"
          + "\t\t\treturn codeLength, err\n"
          + "\t\t}");
      write("}\n");

      if (tag.type == BerImplementationWriter.TagType.EXPLICIT) {

        write(" length := &" + LIB_PREFIX + ".BerLength{}");
        write(" n,err = length.Decode(is)\n");
        write("codeLength += n");
        write("if err != nil {\n"
            + "\t\t\treturn codeLength, err\n"
            + "\t\t}");
        if (isDirectAnyOrChoice((AsnTaggedType) typeDefinition)) {
          write("n,err = b." + embeddedType + ".DecodeWithTag(is, null);");
        } else {
          write("n,err = b. " + embeddedType + ".Decode(is, true)");
        }
        write("codeLength += n");
        write("if err != nil {\n"
            + "\t\t\treturn codeLength, err\n"
            + "\t\t}");
        write("n,err = length.ReadEocIfIndefinite(is)\n");
      } else {
        write("n,err = b. " + embeddedType + ".Decode(is, false)");
      }
      write("codeLength += n");
      write("if err != nil {\n"
          + "\t\t\treturn codeLength, err\n"
          + "\t\t}");

      write("return codeLength,nil");
      write("}\n");
    }
    write("}");
  }

  private String normaliseClassName(String className) {
    String[] l = className.split("\\.");
    if (l.length > 1) {
      return l[l.length - 2] + "." + l[l.length - 1];
    }
    return className;
  }

  @Override
  protected void writeMembers(List<AsnElementType> componentTypes) throws IOException {

    for (AsnElementType element : componentTypes) {
      String className = normaliseClassName(element.className);
      String elementName = Utils.cleanUpName(element.name);
      write(elementName + " *" + className);
    }
    write("");
  }

  @Override
  protected void writeSequenceOrSetClass(
      String className,
      AsnSequenceSet asnSequenceSet,
      BerImplementationWriter.Tag tag,
      String isStaticStr,
      List<String> listOfSubClassNames)
      throws IOException {

    write("type " + className + " struct {");

    List<AsnElementType> componentTypes = asnSequenceSet.componentTypes;
    addAutomaticTagsIfNeeded(componentTypes);
    setClassNamesOfComponents(listOfSubClassNames, componentTypes, className);
    writeMembers(componentTypes);
    write("}");

    BerImplementationWriter.Tag mainTag;
    if (tag == null) {
      if (asnSequenceSet.isSequence) {
        mainTag = stdSeqTag;
      } else {
        mainTag = stdSetTag;
      }
    } else {
      mainTag = tag;
    }

    // Write tag func.
    write("func (b *" + className + ") GetTag () {");
    write("return " + LIB_PREFIX + ".NewBerTag(" + getBerTagParametersString(mainTag) + ")");
    write("}");
    boolean hasExplicitTag = (tag != null) && (tag.type == BerImplementationWriter.TagType.EXPLICIT);

    writeSequenceOrSetEncodeFunction(className, componentTypes, hasExplicitTag, asnSequenceSet.isSequence);
    if (asnSequenceSet.isSequence) {
      writeSequenceDecodeMethod(className, convertToComponentInfos(componentTypes), hasExplicitTag);
    } else {
      writeSetDecodeFunction(className, convertToComponentInfos(componentTypes), hasExplicitTag);
    }
    writeSequenceOrSetToStringFunction(componentTypes);

  }

  @Override
  protected void writeEncodeTag(BerImplementationWriter.Tag tag) throws IOException {
    int typeStructure;

    if (tag.typeStructure == BerImplementationWriter.TypeStructure.CONSTRUCTED) {
      typeStructure = BerTag.CONSTRUCTED;
    } else {
      typeStructure = BerTag.PRIMITIVE;
    }

    BerTag berTag = new BerTag(getTagClassId(tag.tagClass.toString()), typeStructure, tag.value);

    write("// write tag: " + tag.tagClass + "_CLASS, " + tag.typeStructure + ", " + tag.value);
    for (int i = (berTag.tagBytes.length - 1); i >= 0; i--) {
      write("_,_ = " + LIB_PREFIX + ".WriteByte(reverseOS, 0x" + HexString.fromByte(berTag.tagBytes[i]) + ")");
    }

    write("codeLength += " + berTag.tagBytes.length + "");
  }

  @Override
  protected void writeSequenceOrSetEncodeFunction(
      String typeName, List<AsnElementType> componentTypes, boolean hasExplicitTag, boolean isSequence)
      throws IOException {
    write("func (b *" + typeName + ") Encode(reverseOS io.Writer, withTagList ...bool) (int, error) {");

    write("var withTag bool\n"
        + "\tif len(withTagList) > 0 {\n"
        + "\t\twithTag = withTagList[0]\n"
        + "\t} else {\n"
        + "\t\twithTag = true\n"
        + "\t}");

    write("codeLength := 0");
    write("var err error\n"
        + "\tvar n int");
    for (int j = componentTypes.size() - 1; j >= 0; j--) {
      if (isExplicit(getTag(componentTypes.get(j)))) {
        write("var sublength int\n");
        break;
      }
    }

    for (int j = componentTypes.size() - 1; j >= 0; j--) {

      AsnElementType componentType = componentTypes.get(j);

      BerImplementationWriter.Tag componentTag = getTag(componentType);

      if (isOptional(componentType)) {
        write("if b." + getVariableName(componentType) + " != nil {");
      }

      String explicitEncoding = getExplicitEncodingParameter(componentType);

      if (isExplicit(componentTag)) {
        write(
            "n,err = b."
                + getVariableName(componentType)
                + ".Encode(reverseOS"
                + explicitEncoding
                + ")");
        write("sublength += n");
        write("codeLength += sublength");
        write("if err != nil {\n"
            + "\t\t\treturn codeLength, err\n"
            + "\t\t}");
        write("n,err = " + LIB_PREFIX + ".EncodeLength(sublength,reversOS)");
      } else {
        write(
            "n,err = b."
                + getVariableName(componentType)
                + ".encode(reverseOS"
                + explicitEncoding
                + ");");
      }
      write("codeLength += n");
      write("if err != nil {\n"
          + "\t\t\treturn codeLength, err\n"
          + "\t\t}");

      if (componentTag != null) {
        writeEncodeTag(componentTag);
      }
      if (isOptional(componentType)) {
        write("}");
      }

      write("");
    }

    if (hasExplicitTag) {
      write("n,err = " + LIB_PREFIX + ".EncodeLength(codeLength,reverseOS)");
      write("codeLength += n");
      if (isSequence) {
        write("_,_  = " + LIB_PREFIX + ".WriteByte(reverseOS,0x30)");
      } else {
        write("_,_  = " + LIB_PREFIX + ".WriteByte(reverseOS,0x31)");
      }
      write("codeLength++\n");
    }

    write("n,err = " + LIB_PREFIX + ".EncodeLength(codeLength,reverseOS)\n");
    write("codeLength += n");
    write("if withTag {");
    write("n,err = b.GetTag().Encode(reverseOS)");
    write("codeLength += n");
    write("}\n");

    write("if err != nil {\n"
        + "\t\t\treturn codeLength, err\n"
        + "\t\t}");

    write("return codeLength,nil\n");

    write("}\n");
  }


  protected void writeSequenceDecodeMethod(String className, List<ComponentInfo> components, boolean hasExplicitTag)
      throws IOException {
    write("func (b *" + className + ") Decode(is io.Reader, withTagList ...bool) (int, error) {");

    write("var withTag bool\n"
        + "\tif len(withTagList) > 0 {\n"
        + "\t\twithTag = withTagList[0]\n"
        + "\t} else {\n"
        + "\t\twithTag = true\n"
        + "\t}\n"
        + "\tcodeLength := 0");
    write("var err error\n"
        + "\tvar n int");

    write(" tlByteCount := 0");
    write(" vByteCount := 0");
    if (containsUntaggedChoiceOrAny(components)) {
      write("var numDecodedBytes int");
    }
    write("berTag := new(" + LIB_PREFIX + ".BerTag)\n");

    write("if withTag {");
    write("n,err = b.GetTag().decodeAndCheck(is);");
    write("tlByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn codeLength, err\n"
        + "\t\t}");
    write("}\n");

    if (hasExplicitTag) {
      write("explicitTagLength := &" + LIB_PREFIX + ". BerLength{}");
      write("n,err = explicitTagLength.Decode(is)");
      write("tlByteCount += n");
      write("n,err =  " + LIB_PREFIX + ".SEQUENCE.DecodeAndCheck(is)\n");
      write("tlByteCount += n");
      write("if err != nil {\n"
          + "\t\t\treturn codeLength, err\n"
          + "\t\t}");
    }

    write(" length := &" + LIB_PREFIX + ". BerLength{}");
    write("n,err = length.Decode(is)");
    write("tlByteCount += n");
    write("lengthVal := length.Length");

    if (allOptionalOrDefault(components)) {
      write("if lengthVal == 0 {");
      write("return tlByteCount,nil");
      write("}");
    }
    write("n,err = berTag.Decode(is)\n");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn codeLength, err\n"
        + "\t\t}");

    for (ComponentInfo component : components) {
      if (component.isDirectChoiceOrAny && (component.tag == null)) {
        writeSequenceComponentDecodeUntaggedChoiceOrAny(component);
      } else {
        writeSequenceComponentDecodeRegular(component);
        write("");
      }
    }

    if (extensibilityImplied) {
      writeSequenceDecodeMethodExtensibleEnd(hasExplicitTag);
    } else {
      writeSequenceDecodeMethodNonExtensibleEnd(hasExplicitTag);
    }

    write("}\n");
  }

  @Override
  protected void writeSequenceDecodeMethodExtensibleEnd(boolean hasExplicitTag) throws IOException {
    write("if lengthVal < 0 {");
    write("for (!berTag.equals(0, 0, 0)) {");
    write("n,err = " + LIB_PREFIX + ". DecodeUnknownComponent(is)");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    write("vByteCount += n");
    write("n,err = berTag.Decode(is)");
    write("vByteCount += n");
    write("}");

    write("_ =  " + LIB_PREFIX + ".  ReadEocByte(is)");
    write("vByteCount += 1");
    if (hasExplicitTag) {
      write("n,err = explicitTagLength.ReadEocIfIndefinite(is)");
      write("vByteCount += n");
      write("if err != nil {\n"
          + "\t\t\treturn 0, err\n"
          + "\t\t}");
    }
    write("return tlByteCount + vByteCount,nil");
    write("} else {");
    write("for (vByteCount < lengthVal) {");
    write("n,err = " + LIB_PREFIX + ". DecodeUnknownComponent(is)");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    write("if vByteCount == lengthVal {");
    write("return tlByteCount + vByteCount,nil");
    write("}");
    write("n,err = berTag.decode(is)");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    write("}");
    write("}");
    write(
        "return 0,errors.New(fmt.Sprintf(\"unexpected end of sequence, length tag: %d, bytes decoded: %d\", lengthVal, vByteCount))");
  }


  @Override
  protected void writeSequenceComponentDecodeUntaggedChoiceOrAny(ComponentInfo component)
      throws IOException {
    write("b." + component.variableName + " = new (" + normaliseClassName(component.className) + ")");
    write(
        "numDecodedBytes,_ = b."
            + component.variableName
            + ".Decode(is, "
            + getDecodeTagParameter(component)
            + ")");

    write("if numDecodedBytes != 0 {");
    write("vByteCount += numDecodedBytes");

    if (component.mayBeLast) {
      writeReturnIfDefiniteLengthMatchesDecodedBytes();
    }
    write("n,err = berTag.Decode(is)");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    write("}");
    if (component.isOptionalOrDefault) {
      write("else {");
      write("b." + component.variableName + " = nil");
      write("}");
    } else {
      writeElseThrowTagMatchingException();
    }
  }

  @Override
  protected void writeSequenceComponentDecodeRegular(ComponentInfo component) throws IOException {

    if (component.tag != null) {
      write("if (berTag.Equals(" + getBerTagParametersString(component.tag) + ")) {");
    } else {
      write("if (berTag.EqualsTag(b." + component.className + ".GetTag())) {");
    }

    if (isExplicit(component.tag)) {
      write("n,_ = length.Decode(is)");
      write("vByteCount += n");
    }

    write("b." + component.variableName + " = new (" + normaliseClassName(component.className) + ");");
    write(
        "n,err = b."
            + component.variableName
            + ".Decode(is, "
            + getDecodeTagParameter(component)
            + ")");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    if (isExplicit(component.tag)) {
      write("n,err = length.ReadEocIfIndefinite(is)");
      write("vByteCount += n");
      write("if err != nil {\n"
          + "\t\t\treturn 0, err\n"
          + "\t\t}");
    }

    if (component.mayBeLast) {
      writeReturnIfDefiniteLengthMatchesDecodedBytes();
    }
    write("n,err = berTag.decode(is);");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    write("}");
    if (!component.isOptionalOrDefault) {
      writeElseThrowTagMatchingException();
    }
  }

  @Override
  protected void writeSequenceDecodeMethodNonExtensibleEnd(boolean hasExplicitTag)
      throws IOException {
    write("if lengthVal < 0 {");
    write("if !berTag.Equals(0, 0, 0) {");
    write("return 0,errors.New(\"decoded sequence has wrong end of contents octets\")");
    write("}");
    write("n,err =  " + LIB_PREFIX + ".ReadEocByte(is)");
    write("vByteCount += n");
    write("if err != nil {\n"
        + "\t\t\treturn 0, err\n"
        + "\t\t}");
    if (hasExplicitTag) {
      write("n,err = explicitTagLength.ReadEocIfIndefinite(is)");
      write("vByteCount += n");
    }
    write("return tlByteCount + vByteCount,err");
    write("}\n");

    write(
        "return 0,errors.New(fmt.Sprintf(\"unexpected end of sequence, length tag: %d , bytes decoded: %d\",  lengthVal , vByteCount))\n");
  }

  @Override
  protected void writeElseThrowTagMatchingException() throws IOException {
    write("else {");
    write(" return 0,errors.New(\"tag does not match mandatory sequence component.\")");
    write("}");
  }

  @Override
  protected void writeReturnIfDefiniteLengthMatchesDecodedBytes() throws IOException {
    write("if lengthVal >= 0 && vByteCount == lengthVal {");
    write("return tlByteCount + vByteCount,nil");
    write("}");
  }


}
